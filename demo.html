<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explainable MAPF Dashboard</title>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/n3/browser/n3.min.js"></script>

    <script src="https://rdf.js.org/comunica-browser/versions/v4/engines/query-sparql/comunica-browser.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-bg: #F9FAFB;
            --color-panel-bg: #FFFFFF;
            --color-border: #E5E7EB;
            --color-text-main: #374151;
            --color-text-dark: #111827;
            --color-text-muted: #6B7280;
            --color-primary: #ad4c5e;
            --color-primary-dark: #cf5d72;
            --color-secondary: #10B981;
            --color-conflict: #DC2626; /* Red-600 */
            --color-conflict-highlight: rgba(239, 68, 68, 0.35); /* Red-500 with 35% opacity */
            --color-obstacle: #D1D5DB;

            --font-sans: 'Inter', sans-serif;
            --font-mono: 'Fira Code', monospace;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
            --transition-speed: 0.3s ease-in-out;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            width: 100%; height: 100%; font-family: var(--font-sans);
            background-color: var(--color-bg); color: var(--color-text-main);
            overflow: hidden;
        }

        .app-container { display: grid; grid-template-columns: 400px 1fr; height: 100vh; }

        .control-panel {
            background-color: var(--color-bg); padding: 1.5rem;
            display: flex; flex-direction: column; gap: 1.5rem;
            overflow-y: auto; border-right: 1px solid var(--color-border);
        }

        .panel-header h1 { font-size: 1.75rem; font-weight: 700; color: var(--color-text-dark); line-height: 1.2; }
        .panel-header p { font-size: 0.9rem; color: var(--color-text-muted); margin-top: 0.25rem; }

        .control-box {
            background-color: var(--color-panel-bg); border-radius: var(--border-radius);
            padding: 1.5rem; border: 1px solid var(--color-border);
            box-shadow: var(--shadow-sm); transition: all var(--transition-speed);
        }
        
        .control-box h2 { font-size: 1.1rem; font-weight: 600; color: var(--color-text-dark); margin-bottom: 1rem; }

        .file-input-wrapper { position: relative; }
        #ttlInput { display: none; }
        .file-input-label {
            display: flex; align-items: center; justify-content: center; gap: 0.5rem;
            background-color: var(--color-primary); color: white;
            padding: 0.8rem 1rem; border-radius: 8px; text-align: center;
            font-weight: 600; cursor: pointer; transition: all var(--transition-speed);
        }
        .file-input-label:hover { background-color: var(--color-primary-dark); }
        
        #metadataDisplay { font-size: 0.9rem; line-height: 1.6; display: flex; flex-direction: column; gap: 0.5rem; }
        #metadataDisplay div { display: flex; justify-content: space-between; }
        #metadataDisplay span:first-child { font-weight: 500; color: var(--color-text-dark); }
        #metadataDisplay span:last-child { font-weight: 400; color: var(--color-text-muted); }

        #explanationPanelContainer.hidden { display: none; }
        #explanationPanel { display: flex; flex-direction: column; gap: 0.75rem; }

        .question-btn { background-color: #F3F4F6; color: var(--color-text-main); border: 1px solid #E5E7EB; text-align: left; font-weight: 500; width: 100%; padding: 0.75rem 1rem; border-radius: 8px; cursor: pointer; }
        .question-btn:hover { background-color: #E5E7EB; border-color: #D1D5DB; color: var(--color-text-dark); }
        
        .go-back-btn {
            background-color: transparent; border: 1px solid var(--color-border); color: var(--color-text-muted); font-weight: 500; width: auto; padding: 0.5rem 1rem; margin-bottom: 1rem; display: inline-flex; align-items: center; gap: 0.5rem;
        }

        .chat-container { display: flex; flex-direction: column; gap: 1rem; }
        .chat-message { padding: 0.75rem 1rem; border-radius: var(--border-radius); line-height: 1.5; max-width: 95%; }
        .chat-message.user { background-color: var(--color-primary); color: white; border-bottom-right-radius: 4px; align-self: flex-end; }
        .chat-message.bot { background-color: #F3F4F6; color: var(--color-text-main); border-bottom-left-radius: 4px; align-self: flex-start; }
        .chat-message p { margin-bottom: 0.5rem; }
        .chat-message p:last-child { margin-bottom: 0; }
        .chat-message table { width: 100%; border-collapse: collapse; font-size: 0.8rem; margin-top: 0.5rem; table-layout: fixed; }
        .chat-message th, .chat-message td { padding: 0.4rem 0.6rem; text-align: left; border-bottom: 1px solid var(--color-border); word-wrap: break-word; }
        .chat-message th { background-color: #F9FAFB; font-weight: 600; }
        .chat-message ul { margin-left: 1.2rem; margin-top: 0.5rem; margin-bottom: 0.5rem; display: flex; flex-direction: column; gap: 0.4rem; }
        .view-in-sparql-btn { background: none; border: none; font-size: 0.8rem; color: var(--color-primary); font-weight: 600; cursor: pointer; padding: 0.5rem 0 0 0; text-decoration: underline; }

        #agentSelectorContainer {
            border: 1px solid var(--color-border); padding: 1rem; border-radius: var(--border-radius); margin-bottom: 1rem; background-color: var(--color-bg);
        }

        .main-content { display: grid; grid-template-rows: auto 1fr; padding: 1.5rem; gap: 1.5rem; overflow: hidden; }
        .view-switcher { display: flex; gap: 0.5rem; background-color: var(--color-panel-bg); padding: 0.5rem; border-radius: var(--border-radius); box-shadow: var(--shadow-sm); border: 1px solid var(--color-border); }
        .view-switcher button { flex: 1; background-color: transparent; color: var(--color-text-muted); border: none; font-weight: 600; padding: 0.75rem; border-radius: 8px; cursor: pointer; }
        .view-switcher button.active { background-color: var(--color-primary); color: white; box-shadow: var(--shadow-sm); }

        .visualization-area { 
            position: relative; 
            background-color: var(--color-panel-bg); 
            border-radius: var(--border-radius); 
            box-shadow: var(--shadow-md); 
            border: 1px solid var(--color-border); 
            overflow: hidden; 
            display: grid; 
            grid-template-rows: 1fr auto; 
        }
        .vis-container { 
            width: 100%; 
            height: 100%; 
            display: none; 
            overflow: hidden;
            grid-row: 1 / 2;
            grid-column: 1 / 2;
        }
        .vis-container.active { display: flex; flex-direction: column; }
        
        #grid { padding: 1rem; flex-grow: 1; min-height: 0; }
        #sparql { padding: 1.5rem; gap: 1rem; }
        #sparqlQuery { font-family: var(--font-mono); font-size: 0.9rem; padding: 1rem; border-radius: var(--border-radius); border: 1px solid var(--color-border); height: 200px; resize: vertical; width: 100%; background-color: var(--color-bg); color: var(--color-text-dark); }
        #sparqlResult { flex-grow: 1; overflow: auto; font-family: var(--font-mono); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: 1rem; }
        #sparqlResult table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        #sparqlResult th, #sparqlResult td { padding: 0.5rem 0.75rem; text-align: left; border-bottom: 1px solid var(--color-border); }
        #sparqlResult th { background-color: var(--color-panel-bg); font-weight: 600; }

        #gridSvg { width: 100%; height: 100%; }
        .grid-cell { stroke: var(--color-border); stroke-width: 1px; fill: var(--color-panel-bg); cursor: pointer; transition: all 0.2s; }
        .grid-cell:hover { fill: #F3F4F6; }
        .grid-cell.conflict-zone {
            fill: var(--color-conflict-highlight);
            fill-opacity: 0.6;
        }
        .obstacle { fill: var(--color-obstacle); }
        .agent-path { stroke-width: 4px; fill: none; stroke-linecap: round; stroke-linejoin: round; opacity: 0.3; }
        .agent-start-goal { stroke-width: 2px; stroke-dasharray: 4, 4; fill: none; }
        .agent-group { transition: transform 0.2s ease-in-out, opacity 0.4s ease-in-out; }
        .agent { pointer-events: none; }
        .agent-label { font-family: var(--font-sans); font-weight: 700; fill: white; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        
        .dynamic-conflict-highlight {
            fill: var(--color-conflict-highlight);
            stroke: var(--color-conflict);
            stroke-width: 3px;
            pointer-events: none;
        }
        .dynamic-conflict-highlight.edge {
            fill: none;
            stroke-linecap: round;
        }

        .grid-label { font-size: 10px; fill: var(--color-text-muted); text-anchor: middle; dominant-baseline: middle; }

        #simControlsContainer {
            grid-row: 2 / 3;
            grid-column: 1 / 2;
            padding: 1rem 1.5rem; 
            border-top: 1px solid var(--color-border); 
            background-color: var(--color-panel-bg);
            z-index: 10;
        }
        #simControlsContainer.hidden {
            display: none;
        }
        .sim-controls { display: flex; gap: 1rem; align-items: center; }
        .sim-controls button { flex-shrink: 0; padding: 0.5rem; width: 40px; height: 40px; display: grid; place-items: center; }
        .sim-controls input[type=range] { flex-grow: 1; }

        .loading {
            display: flex; align-items: center; justify-content: center; gap: 0.5rem;
            color: var(--color-text-muted); font-size: 0.9rem; padding: 1rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <aside class="control-panel">
            <header class="panel-header">
                <h1>Explainable MAPF</h1>
                <p>Multi-Agent Path Finding Dashboard</p>
            </header>
            <div id="dataSourceBox" class="control-box">
                <h2>Data Source</h2>
                <div id="upload-section">
                    <div class="file-input-wrapper">
                        <label for="ttlInput" class="file-input-label">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg>
                            <span>Upload Knowledge Graph</span>
                        </label>
                        <input type="file" id="ttlInput" accept=".ttl">
                    </div>
                </div>
                <div id="metadataDisplay" style="display: none;"></div>
            </div>
            <div id="explanationPanelContainer" class="control-box hidden">
                <h2 id="explanationPanelTitle">Explanation Panel</h2>
                <div id="agentSelectorContainer" style="display: none;">
                    <label for="agent-select" style="font-weight: 500; display: block; margin-bottom: 0.5rem;">Analyze a specific agent:</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                       <select id="agent-select" style="flex-grow: 1; padding: 0.5rem; border-radius: 4px; border: 1px solid var(--color-border);"></select>
                       <button id="selectAgentBtn" class="file-input-label" style="padding: 0.5rem 1rem; width: auto; flex-shrink: 0;">Select</button>
                    </div>
                </div>
                <div id="explanationPanel">
                </div>
            </div>
        </aside>

        <main class="main-content">
            <nav class="view-switcher">
                <button data-view="grid" class="active">Grid Simulation</button>
                <button data-view="sparql">SPARQL & Query</button>
                <button data-view="documentation">Ontology</button>
            </nav>
            <div class="visualization-area" id="visArea">
                <div id="grid" class="vis-container active">
                    <svg id="gridSvg"></svg>
                </div>
                <div id="sparql" class="vis-container">
                    <textarea id="sparqlQuery" placeholder="Enter SPARQL query here..."></textarea>
                    <div style="display: flex; justify-content: flex-end;">
                        <button id="runSparqlBtn" class="file-input-label" style="width: auto; padding: 0.7rem 1.5rem;">Run Query</button>
                    </div>
                    <pre id="sparqlResult"><p>Query results will appear here.</p></pre>
                </div>
                <div id="documentation" class="vis-container" style="padding: 0; overflow-y: auto;">
                    <iframe src="documentation/webvowl/index.html" style="width: 100%; height: 100vh; border: none;"></iframe>
                </div>
                <div id="simControlsContainer" class="hidden">
                    <div class="sim-controls">
                        <button id="playPauseBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>
                        </button>
                        <input type="range" id="timeSlider" min="0" max="10" value="0" step="1">
                        <span id="timeLabel">T=0</span>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const engine = new Comunica.QueryEngine();
    
            const parseTimestamp = (ts) => {
                if (!ts || typeof ts !== 'string' || !ts.includes('T')) return ts;
                try {
                    return parseInt(ts.split(':').pop().replace('Z', ''));
                } catch (e) {
                    return ts;
                }
            };
    
            const config = {
                agentColors: d3.scaleOrdinal(d3.schemeCategory10),
                animationSpeed: 800,
                prefixes: {
                    ma: 'http://example.org/ma#',
                    owl: 'http://www.w3.org/2002/07/owl#',
                    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
                    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
                    time: 'http://www.w3.org/2006/time#',
                    xsd: 'http://www.w3.org/2001/XMLSchema#',
                    prov: 'http://www.w3.org/ns/prov#'
                }
            };
    
            const state = {
                ttlContent: null,
                fileName: null,
                rdfStore: null,
                gridData: null,
                lastInteraction: null, 
                animationInterval: null,
            };
            
            const rdfProcessor = {
                async parseAndStore(ttlContent) {
                    const N3 = window.N3;
                    const parser = new N3.Parser();
                    const store = new N3.Store();
                    return new Promise((resolve, reject) => {
                        parser.parse(ttlContent, (error, quad) => {
                            if (error) return reject(error);
                            if (quad) store.addQuad(quad);
                            else resolve(store);
                        });
                    });
                },
    
                async extractGridData(store) {
                    const N3 = window.N3;
                    const { namedNode } = N3.DataFactory;
                    const gridData = { gridSize: [0, 0], obstacles: [], agents: {}, conflicts: [], environmentId: null };
                    
                    const envQuad = store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://example.org/ma#Environment'))[0];
                    if (envQuad) {
                        const envSubject = envQuad.subject;
                        gridData.environmentId = envSubject.value.split('#').pop();
                        const width = store.getQuads(envSubject, namedNode('http://example.org/ma#hasGridWidth'), null)[0]?.object.value;
                        const height = store.getQuads(envSubject, namedNode('http://example.org/ma#hasGridHeight'), null)[0]?.object.value;
                        if (width && height) gridData.gridSize = [parseInt(width), parseInt(height)];
                    }

                    store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://example.org/ma#Obstacle')).forEach(q => {
                        const locQuad = store.getQuads(q.subject, namedNode('http://example.org/ma#atLocation'), null)[0];
                        if (locQuad) {
                            const x = store.getQuads(locQuad.object, namedNode('http://example.org/ma#xCoordinate'), null)[0]?.object.value;
                            const y = store.getQuads(locQuad.object, namedNode('http://example.org/ma#yCoordinate'), null)[0]?.object.value;
                            // FIX: Swap x and y here
                            if (x && y) gridData.obstacles.push([parseInt(y), parseInt(x)]);
                        }
                    });
                    
                    store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://example.org/ma#Agent')).forEach(q => {
                        const agentName = q.subject.value.split('#').pop();
                        gridData.agents[agentName] = [];
                    });
                    
                    store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://example.org/ma#JointPlan')).forEach(jpQuad => {
                        store.getQuads(jpQuad.subject, namedNode('http://example.org/ma#composedOfSubPlans'), null).forEach(spQuad => {
                            const belongsTo = store.getQuads(spQuad.object, namedNode('http://example.org/ma#belongsToAgent'), null)[0]?.object.value;
                            if (belongsTo) {
                                const agentName = belongsTo.split('#').pop();
                                store.getQuads(spQuad.object, namedNode('http://example.org/ma#planData'), null).forEach(pdQuad => {
                                    const seg = pdQuad.object;
                                    const timeQuad = store.getQuads(seg, namedNode('http://example.org/ma#hasValidTime'), null)[0];
                                    const pathQuad = store.getQuads(seg, namedNode('http://example.org/ma#hasPathSequence'), null)[0];
                                    if (timeQuad && pathQuad) {
                                        const timeValueQuad = store.getQuads(store.getQuads(timeQuad.object, namedNode('http://www.w3.org/2006/time#hasBeginning'), null)[0]?.object, namedNode('http://www.w3.org/2006/time#inXSDDateTimeStamp'), null)[0];
                                        if (timeValueQuad) {
                                            const time = parseTimestamp(timeValueQuad.object.value);
                                            const pathData = this.extractPathFromList(store, pathQuad.object);
                                            pathData.forEach(cell => gridData.agents[agentName].push({ time, cell }));
                                        }
                                    }
                                });
                            }
                        });
                    });
                    Object.values(gridData.agents).forEach(path => path.sort((a, b) => a.time - b.time));

                    store.getQuads(null, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode('http://example.org/ma#CollisionEvent')).forEach(q => {
                        const locQuad = store.getQuads(q.subject, namedNode('http://example.org/ma#conflictLocation'), null)[0];
                        const timeQuad = store.getQuads(q.subject, namedNode('http://example.org/ma#occursAtTime'), null)[0];
                        if (locQuad && timeQuad) {
                            const x = store.getQuads(locQuad.object, namedNode('http://example.org/ma#xCoordinate'), null)[0]?.object.value;
                            const y = store.getQuads(locQuad.object, namedNode('http://example.org/ma#yCoordinate'), null)[0]?.object.value;
                            const timeStamp = store.getQuads(timeQuad.object, namedNode('http://www.w3.org/2006/time#inXSDDateTimeStamp'), null)[0]?.object.value;
                            // FIX: Swap x and y for raw_location string
                            if (x && y && timeStamp) gridData.conflicts.push({ id: q.subject.value, time: parseTimestamp(timeStamp), raw_location: `${y},${x}`, type: 'vertex' });
                        }
                    });
                    return gridData;
                },

                // --- THIS HELPER FUNCTION IS CORRECTED ---
                extractPathFromList(store, listNode) {
                    const N3 = window.N3;
                    const { namedNode } = N3.DataFactory;
                    const path = [];
                    let currentNode = listNode;
                    while (currentNode && currentNode.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#nil') {
                        const firstQuad = store.getQuads(currentNode, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first'), null)[0];
                        if (firstQuad) {
                            const locNode = firstQuad.object;
                            const x = store.getQuads(locNode, namedNode('http://example.org/ma#xCoordinate'), null)[0]?.object.value;
                            const y = store.getQuads(locNode, namedNode('http://example.org/ma#yCoordinate'), null)[0]?.object.value;
                            // FIX: Swap x and y here
                            if (x && y) path.push([parseInt(y), parseInt(x)]);
                        }
                        currentNode = store.getQuads(currentNode, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'), null)[0]?.object;
                    }
                    return path;
                }
            };
    
            const sparqlQueries = {
                getAgentFinalPlan: ({ agentId }) => ` SELECT ?cost ?timestamp ?x ?y ?conflict WHERE { ma:FinalJointPlan ma:composedOfSubPlans ?plan . ?plan ma:belongsToAgent ma:${agentId} ; ma:hasPlanCost ?cost . ?plan ma:planData ?segment . ?segment ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?timestamp ; ma:hasPathSequence/rdf:rest*/rdf:first ?cellNode . ?cellNode ma:xCoordinate ?x ; ma:yCoordinate ?y . OPTIONAL { ?conflict ma:conflictLocation ?cellNode ; ma:involvesAgentsEvent ma:${agentId} ; ma:occursAtTime/time:inXSDDateTimeStamp ?timestamp . } } ORDER BY ASC(?timestamp) `,
                
                // --- FIX: Swapped ${x} and ${y} to their correct places ---
                getAllConflictsAtLocation: ({ locationStr }) => {
                    const [x, y] = locationStr.split(',');
                    return `
                        SELECT ?conflict ?timestamp ?type (GROUP_CONCAT(DISTINCT STRAFTER(STR(?agent), "#"); separator=", ") AS ?agents) 
                        WHERE {
                            ?conflict a ma:CollisionEvent ; 
                                      ma:conflictLocation ?locNode ; 
                                      ma:occursAtTime/time:inXSDDateTimeStamp ?timestamp ; 
                                      ma:conflictTypeEvent ?type ; 
                                      ma:involvesAgentsEvent ?agent .
                            ?locNode ma:xCoordinate ${x} ; ma:yCoordinate ${y} .
                        } GROUP BY ?conflict ?timestamp ?type ORDER BY ?timestamp
                    `;
                },
                
                getAllAgentConflicts: ({ agentId }) => ` SELECT ?conflict ?timestamp ?type (GROUP_CONCAT(DISTINCT STRAFTER(STR(?otherAgent), "#"); separator=", ") as ?involvedAgents) (GROUP_CONCAT(CONCAT("(", STR(?y), ",", STR(?x), ")"); separator=";") as ?locations) WHERE { ?conflict a ma:CollisionEvent ; ma:involvesAgentsEvent ma:${agentId}, ?otherAgent ; ma:occursAtTime/time:inXSDDateTimeStamp ?timestamp ; ma:conflictTypeEvent ?type ; ma:conflictLocation ?locNode . ?locNode ma:xCoordinate ?x ; ma:yCoordinate ?y . FILTER(?otherAgent != ma:${agentId}) } GROUP BY ?conflict ?timestamp ?type ORDER BY ?timestamp `,
                explainConflictResolutionAndPlanChange: ({ conflictURI }) => ` SELECT ?resolvedPlan ?replanningAgentName ?otherAgentName ?rationale ?alertType ?originalCost ?newCost (GROUP_CONCAT(CONCAT("(", STR(?y), ",", STR(?x), ")"); separator=";") as ?locations) WHERE { BIND(<${conflictURI}> as ?conflict) ?resolvedPlan a ma:ResolvedSubPlan ; ma:resolvesConflict ?conflict ; ma:belongsToAgent ?replanningAgent ; ma:hasPlanCost ?newCost ; ma:generatedBy ?activity . ?activity prov:used ?strategy . ?strategy ma:triggeredBy ?alert . ?alert ma:selectionRationale ?rationale . OPTIONAL { ?alert ma:alertType ?alertType . } ?resolvedPlan ma:derivesFrom ?originalPlan . ?originalPlan a ma:OriginalSubPlan ; ma:hasPlanCost ?originalCost . ?conflict ma:involvesAgentsEvent ?otherAgent ; ma:conflictLocation ?locNode . ?locNode ma:xCoordinate ?x ; ma:yCoordinate ?y . FILTER(?replanningAgent != ?otherAgent) BIND(STRAFTER(STR(?replanningAgent), "#") AS ?replanningAgentName) BIND(STRAFTER(STR(?otherAgent), "#") AS ?otherAgentName) } GROUP BY ?resolvedPlan ?replanningAgentName ?otherAgentName ?rationale ?alertType ?originalCost ?newCost `,
                explainAgentWait: ({ agentId }) => ` SELECT ?startTS ?endTS ?otherAgentName ?conflictTS ?x ?y WHERE { ?resolvedPlan a ma:ResolvedSubPlan; ma:belongsToAgent ma:${agentId} . FILTER EXISTS { ma:FinalJointPlan ma:composedOfSubPlans ?resolvedPlan . } ?resolvedPlan ma:planData ?seg1, ?seg2 . ?seg1 ma:hasPathSequence/rdf:rest*/rdf:first ?locNode . ?seg1 ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?startTS . ?seg2 ma:hasPathSequence/rdf:rest*/rdf:first ?locNode . ?seg2 ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?endTS . ?resolvedPlan ma:resolvesConflict ?conflict . ?conflict ma:involvesAgentsEvent ?otherAgent ; ma:occursAtTime/time:inXSDDateTimeStamp ?conflictTS ; ma:conflictLocation ?locNode . ?locNode ma:xCoordinate ?x ; ma:yCoordinate ?y . FILTER(?otherAgent != ma:${agentId}) BIND(STRAFTER(STR(?otherAgent), "#") AS ?otherAgentName) } `,
                getPlanMakespan: () => ` SELECT ?makespan WHERE { ma:FinalJointPlan ma:hasGlobalMakespan ?makespan . } `,
                getCostByAgent: () => ` SELECT (STRAFTER(STR(?agent), "#") AS ?agentName) ?cost WHERE { ma:FinalJointPlan ma:composedOfSubPlans ?plan . ?plan ma:belongsToAgent ?agent ; ma:hasPlanCost ?cost . } ORDER BY ?agentName `,
                compareOriginalResolved: ({ agentId }) => ` SELECT ?phase ?timestamp ?x ?y ?originalCost ?newCost WHERE { ?orig a ma:OriginalSubPlan ; ma:belongsToAgent ma:${agentId} ; ma:hasPlanCost ?originalCost . ?res a ma:ResolvedSubPlan ; ma:belongsToAgent ma:${agentId} ; ma:hasPlanCost ?newCost . FILTER EXISTS { ma:FinalJointPlan ma:composedOfSubPlans ?res . } { ?orig ma:planData ?seg . ?seg ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?timestamp ; ma:hasPathSequence/rdf:rest*/rdf:first ?cellNode . ?cellNode ma:xCoordinate ?x ; ma:yCoordinate ?y . BIND("Original" AS ?phase) } UNION { ?res ma:planData ?seg . ?seg ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?timestamp ; ma:hasPathSequence/rdf:rest*/rdf:first ?cellNode . ?cellNode ma:xCoordinate ?x ; ma:yCoordinate ?y . BIND("Resolved" AS ?phase) } } ORDER BY ?phase ?timestamp `,
                findMostCongestedLocations: () => ` SELECT ?x ?y (COUNT(?conflict) AS ?conflictCount) WHERE { ?conflict a ma:CollisionEvent ; ma:conflictLocation ?locNode . ?locNode ma:xCoordinate ?x ; ma:yCoordinate ?y . } GROUP BY ?x ?y ORDER BY DESC(?conflictCount) LIMIT 5 `,
                countReplans: () => ` SELECT (COUNT(?res) as ?replanCount) WHERE { ma:FinalJointPlan ma:composedOfSubPlans ?res . ?res a ma:ResolvedSubPlan . } `,
                getAgentResolutionHistory: ({ agentId }) => ` SELECT ?plan ?planType ?planCost ?timestamp ?x ?y ?rationale (GROUP_CONCAT(DISTINCT STRAFTER(STR(?otherAgent), "#"); separator=", ") AS ?otherAgentName) WHERE { BIND(ma:${agentId} AS ?agent) { { ?plan a ma:OriginalSubPlan ; ma:belongsToAgent ?agent ; ma:hasPlanCost ?planCost . BIND("Original Plan" as ?planType) BIND("N/A" as ?timestamp) BIND("N/A" as ?x) BIND("N/A" as ?y) BIND("Initial plan generation" as ?rationale) } UNION { ?plan a ma:ResolvedSubPlan ; ma:belongsToAgent ?agent ; ma:hasPlanCost ?planCost ; ma:resolvesConflict ?conflict ; ma:generatedBy ?activity . ?activity prov:used ?strategy . ?strategy ma:triggeredBy ?alert . ?alert ma:selectionRationale ?rationale . ?conflict ma:occursAtTime/time:inXSDDateTimeStamp ?timestamp ; ma:conflictLocation ?locNode ; ma:involvesAgentsEvent ?otherAgent . ?locNode ma:xCoordinate ?x ; ma:yCoordinate ?y . FILTER(?otherAgent != ?agent) BIND("Resolved Plan" as ?planType) } } } GROUP BY ?plan ?planType ?planCost ?timestamp ?x ?y ?rationale `,
                getPathsForAgentPlans: ({ agentId }) => ` SELECT ?plan ?timestamp ?x ?y WHERE { ?plan ma:belongsToAgent ma:${agentId} . ?plan ma:planData ?segment . ?segment ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?timestamp ; ma:hasPathSequence/rdf:rest*/rdf:first ?cellNode . ?cellNode ma:xCoordinate ?x ; ma:yCoordinate ?y . } ORDER BY ?plan ?timestamp `,
                getPathForPlan: ({ planURI }) => ` SELECT ?timestamp ?x ?y WHERE { <${planURI}> ma:planData ?segment . ?segment ma:hasValidTime/time:hasBeginning/time:inXSDDateTimeStamp ?timestamp ; ma:hasPathSequence/rdf:rest*/rdf:first ?cellNode . ?cellNode ma:xCoordinate ?x ; ma:yCoordinate ?y . } ORDER BY ?timestamp `
            };
        
            const explanationEngine = {
                _parseTimeFromTimestamp(timestampStr) { return parseTimestamp(timestampStr); },
                async generateExplanation(question, queryKey, results) {
                    let content = '';
                    const followUps = [];
                    const params = state.lastInteraction.params;
        
                    if (!results || results.length === 0) {
                        content = `<p>I couldn't find any specific details for that query.</p>`;
                        ui.highlightConflicts([]);
                    } else {
                        const conflictIdsToHighlight = results.flatMap(r => r.conflict ? r.conflict.split(',') : []).filter(Boolean);
                        if (state.lastInteraction.conflictURI) conflictIdsToHighlight.push(state.lastInteraction.conflictURI);
                        if (conflictIdsToHighlight.length > 0) ui.highlightConflicts(conflictIdsToHighlight);
                        else ui.highlightConflicts([]);
    
                        switch (queryKey) {
                            case 'getAgentResolutionHistory': {
                                const agentName = ui.getAgentDisplayName(params.agentId);
                                let explanationHtml = `<p>Here is the step-by-step resolution history for <strong>${agentName}</strong>:</p>`;
                                
                                const allPathData = await app.executeSparqlQuery(sparqlQueries.getPathsForAgentPlans(params));
                                const pathsByPlan = d3.group(allPathData, d => d.plan);
                                
                                // --- FIX: Robust sorting in JavaScript to ensure order ---
                                results.sort((a, b) => {
                                    if (a.planType === 'Original Plan') return -1;
                                    if (b.planType === 'Original Plan') return 1;
                                    return this._parseTimeFromTimestamp(a.timestamp) - this._parseTimeFromTimestamp(b.timestamp);
                                });
    
                                results.forEach((step, index) => {
                                    const pathSegments = pathsByPlan.get(step.plan) || [];
                                    pathSegments.sort((a,b) => this._parseTimeFromTimestamp(a.timestamp) - this._parseTimeFromTimestamp(b.timestamp));
                                    const pathString = pathSegments.map(p => `(${p.x},${p.y})`).join(' → ');
                                    explanationHtml += `<hr style="margin: 0.75rem 0; border-color: var(--color-border);">`;
    
                                    if (step.planType === 'Original Plan') {
                                        explanationHtml += `<p><strong>Step 0: Initial Plan</strong><br>The first plan was generated with an initial cost of <strong>${parseFloat(step.planCost).toFixed(2)}</strong>.</p>`;
                                        if (pathString) explanationHtml += `<p style="font-size:0.8rem; word-break:break-all; margin-top: 0.5rem;"><strong>Path:</strong> ${pathString}</p>`;
                                    } else {
                                        const prevStep = results[index - 1];
                                        const prevPlanId = prevStep.plan;
                                        const prevPathSegments = pathsByPlan.get(prevPlanId) || [];
                                        prevPathSegments.sort((a,b) => this._parseTimeFromTimestamp(a.timestamp) - this._parseTimeFromTimestamp(b.timestamp));
                                        const prevPathString = prevPathSegments.map(p => `(${p.x},${p.y})`).join(' → ');
                                        const cost = parseFloat(step.planCost), prevCost = parseFloat(prevStep.planCost), change = cost - prevCost;
                                        let costChangeHtml = (change > 0) ? `an increase of <span style="color: #DC2626;">${change.toFixed(2)}</span>` : (change < 0) ? `a decrease of <span style="color: #10B981;">${Math.abs(change).toFixed(2)}</span>` : `no change`;
                                        const otherAgents = step.otherAgentName ? step.otherAgentName.split(',').map(name => ui.getAgentDisplayName(name.trim())).join(', ') : '';
                                        const otherAgentDisplay = otherAgents ? ` with <strong>${otherAgents}</strong>` : '';
                                        explanationHtml += `<p><strong>Step ${index}: Replanning Event</strong></p><p><strong>Conflict Details:</strong> A conflict was detected${otherAgentDisplay} at time <strong>T=${step.timestamp}</strong> in location <strong>(${step.x},${step.y})</strong>.</p><p><strong>Resulting Plan Change:</strong></p><ul><li>The plan cost changed from <strong>${prevCost.toFixed(2)}</strong> to <strong>${cost.toFixed(2)}</strong> (${costChangeHtml}).</li><li><strong>Old Path:</strong> <span style="font-size:0.8rem; word-break:break-all;">${prevPathString}</span></li><li><strong>New Path:</strong> <span style="font-size:0.8rem; word-break:break-all;">${pathString}</span></li></ul><p style="font-size:0.9em; color: var(--color-text-muted); margin-top: 0.25rem;"><em>Planner Rationale: "${step.rationale}"</em></p>`;
                                    }
                                });
                                content = explanationHtml;
                                break;
                            }
                            // Other cases from your ideal implementation are restored here...
                            default: {
                                // Find the full explanation logic in the app object below to keep this readable.
                                // This default is a fallback.
                                content = `<p>Here is the data I found:</p>`;
                                content += ui.createResultsTable(results);
                            }
                        }
                    }
                    ui.renderChatResponse(question, content, queryKey, results, followUps);
                },
            };
            // We have to put the full generateExplanation logic here because of its size and complexity
            explanationEngine.generateExplanation = async function(question, queryKey, results) { let content = ''; const followUps = []; const params = state.lastInteraction.params; if (!results || results.length === 0) { content = `<p>I couldn't find any specific details for that query.</p>`; ui.highlightConflicts([]); } else { const conflictIdsToHighlight = results.flatMap(r => r.conflict ? r.conflict.split(',') : []).filter(Boolean); if (state.lastInteraction.conflictURI) { conflictIdsToHighlight.push(state.lastInteraction.conflictURI); } if (conflictIdsToHighlight.length > 0) { ui.highlightConflicts(conflictIdsToHighlight); } else { ui.highlightConflicts([]); } switch (queryKey) { case 'getAgentFinalPlan': { const agentId = params.agentId; const agentName = ui.getAgentDisplayName(agentId); const uniqueSteps = Array.from(d3.group(results, d => d.timestamp).values()).map(group => group[0]); const cost = uniqueSteps[0].cost; const path = uniqueSteps.map(r => `(${r.x},${r.y})`); const trajectoryString = path.join(' → '); const summary = ui.summarizeTrajectory(path); content = `<p>The final plan for <strong>${agentName}</strong> has a cost of <strong>${cost}</strong>.</p> <p><strong>Summary:</strong> ${summary}</p> <p><strong>Full Path:</strong></p> <p style="font-size:0.8rem; word-break:break-all;">${trajectoryString}</p>`; followUps.push({ text: `What conflicts was ${agentName} in?`, queryKey: 'getAllAgentConflicts', params: { agentId } }); if (path.some((cell, i) => i > 0 && cell === path[i-1])) { followUps.push({ text: `Why did ${agentName} have to wait?`, queryKey: 'explainAgentWait', params: { agentId } }); } break; } case 'getAllAgentConflicts': { const agentNameForConflicts = ui.getAgentDisplayName(params.agentId); content = `<p><strong>${agentNameForConflicts}</strong> was involved in these conflicts (highlighted on grid):</p>`; const processedResults = results.map(r => ({ time: r.timestamp, type: r.type, location: r.locations, with: r.involvedAgents.split(',').map(ui.getAgentDisplayName).join(', ') })); content += ui.createResultsTable(processedResults); results.forEach(conflict => { followUps.push({ text: `How was the conflict at ${conflict.locations} resolved?`, type: 'follow-up', queryKey: 'explainConflictResolutionAndPlanChange', params: { conflictURI: conflict.conflict } }); }); break; } case 'getAllConflictsAtLocation': { content = `<p>The following conflicts occurred at this location (highlighted on grid):</p>`; const processedResults = results.map(r => ({ time: r.timestamp, type: r.type, agents: r.agents.split(',').map(ui.getAgentDisplayName).join(', ') })); content += ui.createResultsTable(processedResults); results.forEach(conflict => { followUps.push({ text: `How was the conflict at T=${r.timestamp} resolved?`, type: 'follow-up', queryKey: 'explainConflictResolutionAndPlanChange', params: { conflictURI: conflict.conflict } }); }); break; } case 'explainConflictResolutionAndPlanChange': { const res = results[0]; const pathData = await app.executeSparqlQuery(sparqlQueries.getPathForPlan({ planURI: res.resolvedPlan })); const newPathString = pathData.map(p => `(${p.x},${p.y})`).join(' → '); content = `<p>A conflict occurred at location <strong>${res.locations}</strong>.</p> <p>To resolve the conflict with <strong>${ui.getAgentDisplayName(res.otherAgentName)}</strong>, <strong>${ui.getAgentDisplayName(res.replanningAgentName)}</strong> changed its plan.</p> <p style="font-size:0.9em; word-break:break-all; margin-top: 0.5rem;"><strong>Show new plan:</strong> ${newPathString}</p> <p>This changed the plan cost from <strong>${res.originalCost}</strong> to <strong>${res.newCost}</strong>.</p> <p><strong>Rationale:</strong> Using a <strong>${res.alertType || 'default'}</strong> strategy, ${res.rationale}</p>`; break; } case 'explainAgentWait': { const waits = results.filter(r => r.endTS === r.startTS + 1); if (!waits || waits.length === 0) { content = `<p><strong>${ui.getAgentDisplayName(params.agentId)}</strong> did not have any wait states in its final plan.</p>`; } else { const totalWait = waits.length; const waitInfo = waits[0]; const conflictTime = waitInfo.conflictTS; const waitingAgentName = ui.getAgentDisplayName(params.agentId); content = `<p><strong>${waitingAgentName}</strong> had to wait for a total of <strong>${totalWait}</strong> second(s) in its final plan.</p> <p>This was necessary to avoid a planned conflict with <strong>${ui.getAgentDisplayName(waitInfo.otherAgentName)}</strong> that would have occurred at (${waitInfo.x},${waitInfo.y}) at T=${conflictTime}.</p>`; } break; } case 'getPlanMakespan': { const makespan = results[0].makespan; const costData = await app.executeSparqlQuery(sparqlQueries.getCostByAgent()); const replanData = await app.executeSparqlQuery(sparqlQueries.countReplans()); const sumOfCosts = costData.reduce((sum, row) => sum + parseFloat(row.cost), 0); const replanCount = replanData.length > 0 ? replanData[0].replanCount : 0; content = `<p>Here is a summary of the final joint plan:</p> <p>The overall <strong>makespan</strong> is <strong>${makespan}</strong>.</p> <p>The <strong>sum of individual plan costs</strong> is <strong>${sumOfCosts.toFixed(2)}</strong>.</p> <p>A total of <strong>${replanCount} replans</strong> were required.</p>`; break; } case 'getCostByAgent': { content = `<p>The final plan cost for each agent is as follows:</p>`; const costResults = results.map(r => ({ Agent: ui.getAgentDisplayName(r.agentName), Cost: parseFloat(r.cost).toFixed(2) })); content += ui.createResultsTable(costResults); break; } case 'compareOriginalResolved': { const agentName = ui.getAgentDisplayName(params.agentId); const originalPath = results.filter(r => r.phase === 'Original').map(r => `(${r.x},${r.y})`); const resolvedPath = results.filter(r => r.phase === 'Resolved').map(r => `(${r.x},${r.y})`); const originalCost = parseFloat(results[0].originalCost).toFixed(2); const newCost = parseFloat(results[0].newCost).toFixed(2); const costIncrease = (newCost - originalCost).toFixed(2); content = `<p>Comparison for <strong>${agentName}</strong>:</p> <p>The <strong>original plan</strong> cost was <strong>${originalCost}</strong>.</p> <p>The <strong>new resolved plan</strong> cost is <strong>${newCost}</strong> (increase of <strong>${costIncrease}</strong>).</p> <hr style="margin: 1rem 0; border-color: var(--color-border);"> <p><strong>Original Path:</strong> ${originalPath.join(' → ')}</p> <p><strong>Resolved Path:</strong> ${resolvedPath.join(' → ')}</p>`; break; } case 'findMostCongestedLocations': { content = `<p>The most congested locations are:</p>`; const congestionResults = results.map(r => ({ Location: `(${r.x},${r.y})`, 'Conflict Count': r.conflictCount })); content += ui.createResultsTable(congestionResults); break; } case 'getAgentResolutionHistory': { const agentName = ui.getAgentDisplayName(params.agentId); let explanationHtml = `<p>Here is the step-by-step resolution history for <strong>${agentName}</strong>:</p>`; const allPathData = await app.executeSparqlQuery(sparqlQueries.getPathsForAgentPlans(params)); const pathsByPlan = d3.group(allPathData, d => d.plan); results.sort((a, b) => { if (a.planType === 'Original Plan') return -1; if (b.planType === 'Original Plan') return 1; return a.timestamp - b.timestamp; }); results.forEach((step, index) => { const pathString = (pathsByPlan.get(step.plan) || []).map(p => `(${p.x},${p.y})`).join(' → '); explanationHtml += `<hr style="margin: 0.75rem 0; border-color: var(--color-border);">`; if (step.planType === 'Original Plan') { explanationHtml += `<p><strong>Step 0: Initial Plan</strong><br> The first plan was generated with an initial cost of <strong>${parseFloat(step.planCost).toFixed(2)}</strong>.</p>`; if (pathString) { explanationHtml += `<p style="font-size:0.8rem; word-break:break-all; margin-top: 0.5rem;"><strong>Path:</strong> ${pathString}</p>`; } } else { const prevStep = results[index - 1]; const prevPathId = prevStep.plan; const prevPathString = (pathsByPlan.get(prevPathId) || []).map(p => `(${p.x},${p.y})`).join(' → '); const cost = parseFloat(step.planCost), prevCost = parseFloat(prevStep.planCost), change = cost - prevCost; let costChangeHtml = (change > 0) ? `an increase of <span style="color: #DC2626;">${change.toFixed(2)}</span>` : (change < 0) ? `a decrease of <span style="color: #10B981;">${Math.abs(change).toFixed(2)}</span>` : `no change`; const otherAgents = step.otherAgentName ? step.otherAgentName.split(',').map(name => ui.getAgentDisplayName(name.trim())).join(', ') : ''; const otherAgentDisplay = otherAgents ? ` with <strong>${otherAgents}</strong>` : ''; explanationHtml += `<p><strong>Step ${index}: Replanning Event</strong></p> <p><strong>Conflict Details:</strong> A conflict was detected${otherAgentDisplay} at time <strong>T=${step.timestamp}</strong> in location <strong>(${step.x},${step.y})</strong>.</p> <p><strong>Resulting Plan Change:</strong></p> <ul> <li>The plan cost changed from <strong>${prevCost.toFixed(2)}</strong> to <strong>${cost.toFixed(2)}</strong> (${costChangeHtml}).</li> <li><strong>Old Path:</strong> <span style="font-size:0.8rem; word-break:break-all;">${prevPathString}</span></li> <li><strong>New Path:</strong> <span style="font-size:0.8rem; word-break:break-all;">${pathString}</span></li> </ul> <p style="font-size:0.9em; color: var(--color-text-muted); margin-top: 0.25rem;"> <em>Planner Rationale: "${step.rationale}"</em></p>`; } }); content = explanationHtml; break; } default: { content = `<p>Here is the data I found:</p>`; content += ui.createResultsTable(results); } } } ui.renderChatResponse(question, content, queryKey, results, followUps); };
    
            const ui = {
                dom: { explanationPanelContainer: document.getElementById('explanationPanelContainer'), explanationPanel: document.getElementById('explanationPanel'), explanationPanelTitle: document.getElementById('explanationPanelTitle'), agentSelectorContainer: document.getElementById('agentSelectorContainer'), agentSelect: document.getElementById('agent-select'), selectAgentBtn: document.getElementById('selectAgentBtn'), ttlInput: document.getElementById('ttlInput'), metadataDisplay: document.getElementById('metadataDisplay'), uploadSection: document.getElementById('upload-section'), simControlsContainer: document.getElementById('simControlsContainer'), playPauseBtn: document.getElementById('playPauseBtn'), timeSlider: document.getElementById('timeSlider'), timeLabel: document.getElementById('timeLabel'), sparqlQuery: document.getElementById('sparqlQuery'), sparqlResult: document.getElementById('sparqlResult'), runSparqlBtn: document.getElementById('runSparqlBtn'), gridSvg: d3.select('#gridSvg'), },
                getAgentDisplayName(agentId) { if (!agentId || typeof agentId !== 'string') return ''; const name = agentId.includes(':') ? agentId.split(':')[1] : agentId; const parts = name.split('-'); return `Agent ${parts[1] || name}`; },
                summarizeTrajectory(path) { if (!path || path.length < 2) return 'The agent does not move.'; let summaryParts = []; let i = 0; while (i < path.length - 1) { let currentCell = path[i]; let waitCount = 0; while (i + 1 < path.length && path[i+1] === currentCell) { waitCount++; i++; } if (waitCount > 0) summaryParts.push(`<strong>waits</strong> at ${currentCell} for ${waitCount} step(s)`); if (i + 1 < path.length) summaryParts.push(`<strong>moves</strong> to ${path[i+1]}`); i++; } return `The agent starts at ${path[0]}, then ${summaryParts.join(', then ')}.`; },
                switchView(viewName) { document.querySelectorAll('.view-switcher button').forEach(btn => btn.classList.toggle('active', btn.dataset.view === viewName)); document.querySelectorAll('.vis-container').forEach(container => container.classList.toggle('active', container.id === viewName)); const showSimControls = viewName === 'grid' && state.gridData; this.dom.simControlsContainer.classList.toggle('hidden', !showSimControls); if (viewName !== 'grid') this.highlightConflicts([]); },
                displayMetadata() { const { fileName, gridData } = state; this.dom.uploadSection.style.display = 'none'; this.dom.metadataDisplay.innerHTML = `<div><span>File Name:</span> <span>${fileName}</span></div><div><span>Environment:</span> <span>${gridData.environmentId || 'N/A'}</span></div><div><span>Agent Count:</span> <span>${Object.keys(gridData.agents).length}</span></div><div><span>Obstacle Count:</span> <span>${gridData.obstacles.length}</span></div><div><span>Conflict Count:</span> <span>${gridData.conflicts.length}</span></div><button id="changeFileBtn" class="question-btn" style="margin-top: 1rem;">Change File</button>`; this.dom.metadataDisplay.style.display = 'flex'; document.getElementById('changeFileBtn').addEventListener('click', () => this.dom.ttlInput.click()); },
                createResultsTable(results) { if (!results || !results.length) return ''; const headers = Object.keys(results[0]); const table = document.createElement('table'); table.innerHTML = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`; const tbody = document.createElement('tbody'); results.forEach(row => { const tr = document.createElement('tr'); headers.forEach(h => { const value = row[h] ?? ''; const td = document.createElement('td'); td.textContent = value; td.title = value; tr.appendChild(td); }); tbody.appendChild(tr); }); table.appendChild(tbody); return `<div style="overflow-x: auto; padding-bottom: 0.5rem;">${table.outerHTML}</div>`; },
                renderChatResponse(question, botContent, queryKey, rawResults, followUps = []) { this.dom.explanationPanel.innerHTML = ''; this.addGoBackButton(); const chatContainer = document.createElement('div'); chatContainer.className = 'chat-container'; const userMsg = document.createElement('div'); userMsg.className = 'chat-message user'; userMsg.textContent = question; const botMsg = document.createElement('div'); botMsg.className = 'chat-message bot'; botMsg.innerHTML = botContent; if (sparqlQueries[queryKey] && state.lastInteraction?.params) { const sparqlQuery = sparqlQueries[queryKey](state.lastInteraction.params); const viewBtn = document.createElement('button'); viewBtn.className = 'view-in-sparql-btn'; viewBtn.textContent = 'View in SPARQL Tab'; viewBtn.onclick = () => { let fullQueryForDisplay = ''; Object.entries(config.prefixes).forEach(([prefix, uri]) => { fullQueryForDisplay += `PREFIX ${prefix}: <${uri}>\n`; }); this.dom.sparqlQuery.value = fullQueryForDisplay + '\n' + sparqlQuery; this.dom.sparqlResult.innerHTML = this.createResultsTable(rawResults); this.switchView('sparql'); }; botMsg.appendChild(viewBtn); } chatContainer.appendChild(userMsg); chatContainer.appendChild(botMsg); this.dom.explanationPanel.appendChild(chatContainer); if (followUps.length > 0) { const followUpHeader = document.createElement('p'); followUpHeader.textContent = 'Further questions:'; followUpHeader.style.fontWeight = '500'; followUpHeader.style.marginTop = '1rem'; this.dom.explanationPanel.appendChild(followUpHeader); followUps.forEach(q => this.addQuestionButton(q)); } },
                addGoBackButton() { const backBtn = document.createElement('button'); backBtn.className = 'question-btn go-back-btn'; backBtn.textContent = '← Go Back'; backBtn.dataset.type = 'back-to-initial'; this.dom.explanationPanel.appendChild(backBtn); },
                addQuestionButton(q) { const btn = document.createElement('button'); btn.className = 'question-btn'; btn.textContent = q.text; btn.dataset.type = q.type || 'question'; btn.dataset.queryKey = q.queryKey || ''; btn.dataset.params = JSON.stringify(q.params || {}); this.dom.explanationPanel.appendChild(btn); },
                renderInitialQuestionList(questions, title, showAgentSelector) { this.dom.explanationPanelTitle.textContent = title; this.dom.agentSelectorContainer.style.display = showAgentSelector ? 'block' : 'none'; this.dom.explanationPanel.innerHTML = ''; questions.forEach(q => this.addQuestionButton(q)); this.dom.explanationPanelContainer.classList.remove('hidden'); },
                drawGrid() { this.dom.gridSvg.selectAll('*').remove(); if (!state.gridData) return; const { width, height } = document.getElementById('grid').getBoundingClientRect(); const [cols, rows] = state.gridData.gridSize; const padding = 40; const cellSize = Math.max(10, Math.floor(Math.min((width - padding) / cols, (height - padding) / rows))); const gridWidth = cols * cellSize; const gridHeight = rows * cellSize; const g = this.dom.gridSvg.append('g').attr('transform', `translate(${(width - gridWidth) / 2}, ${(height - gridHeight) / 2})`); const cellLayer = g.append('g').attr('id', 'cellLayer'); g.append('g').attr('id', 'conflictHighlightLayer'); const pathLayer = g.append('g').attr('id', 'pathLayer'); const goalLayer = g.append('g').attr('id', 'goalLayer'); const agentLayer = g.append('g').attr('id', 'agentLayer'); for(let i = 0; i < cols; i++) { g.append('text').attr('class', 'grid-label').attr('x', i * cellSize + cellSize/2).attr('y', -10).text(i); } for(let j = 0; j < rows; j++) { g.append('text').attr('class', 'grid-label').attr('x', -10).attr('y', j * cellSize + cellSize/2).text(j); } for (let j = 0; j < rows; j++) { for (let i = 0; i < cols; i++) { cellLayer.append('rect').attr('x', i * cellSize).attr('y', j * cellSize).attr('width', cellSize).attr('height', cellSize).attr('class', 'grid-cell').attr('id', `cell-${i}-${j}`).on('click', () => app.handleCellClick(i, j)); } } cellLayer.selectAll('.obstacle').data(state.gridData.obstacles).enter().append('rect').attr('class', 'obstacle').attr('x', d => d[0] * cellSize).attr('y', d => d[1] * cellSize).attr('width', cellSize).attr('height', cellSize).attr('rx', 4); const conflictLocations = new Set(state.gridData.conflicts.map(c => c.raw_location)); conflictLocations.forEach(locStr => { const [x, y] = locStr.split(','); d3.select(`#cell-${x}-${y}`).classed('conflict-zone', true); }); const line = d3.line().x(d => d.cell[0] * cellSize + cellSize / 2).y(d => d.cell[1] * cellSize + cellSize / 2); Object.entries(state.gridData.agents).forEach(([id, path]) => { const agentPathData = path.map(p => ({cell: p.cell})); pathLayer.append('path').attr('class', 'agent-path').attr('d', line(agentPathData)).style('stroke', config.agentColors(id)); if (path.length > 0) { const goal = path[path.length - 1].cell; goalLayer.append('rect').attr('class', 'agent-start-goal').attr('x', goal[0] * cellSize + 4).attr('y', goal[1] * cellSize + 4).attr('width', cellSize - 8).attr('height', cellSize - 8).attr('rx', 4).style('stroke', config.agentColors(id)); const agentNum = id.split('-').pop(); const start = path[0].cell; const agentGroup = agentLayer.append('g').attr('class', 'agent-group').attr('id', `agent-group-${id}`).attr('transform', `translate(${start[0] * cellSize}, ${start[1] * cellSize})`); agentGroup.append('rect').attr('class', 'agent').attr('width', cellSize - 4).attr('height', cellSize - 4).attr('x', 2).attr('y', 2).attr('rx', 4).style('fill', config.agentColors(id)); agentGroup.append('text').attr('class', 'agent-label').attr('x', cellSize / 2).attr('y', cellSize / 2).attr('font-size', `${Math.max(8, cellSize * 0.5)}px`).text(agentNum); } }); },
                highlightConflicts(conflictIds) { const highlightLayer = this.dom.gridSvg.select('#conflictHighlightLayer'); highlightLayer.selectAll('*').remove(); if (!state.gridData || conflictIds.length === 0) return; const { width, height } = document.getElementById('grid').getBoundingClientRect(); const [cols, rows] = state.gridData.gridSize; const padding = 40; const cellSize = Math.max(10, Math.floor(Math.min((width - padding) / cols, (height - padding) / rows))); const conflictsToHighlight = state.gridData.conflicts.filter(c => conflictIds.includes(c.id)); conflictsToHighlight.forEach(c => { const [x, y] = c.raw_location.split(','); highlightLayer.append('rect').attr('class', 'dynamic-conflict-highlight vertex').attr('x', x * cellSize + 2).attr('y', y * cellSize + 2).attr('width', cellSize - 4).attr('height', cellSize - 4).attr('rx', 4); }); },
                updateSimulation(time) { this.dom.timeSlider.value = time; this.dom.timeLabel.textContent = `T=${time}`; if (!state.gridData) return; const { width, height } = document.getElementById('grid').getBoundingClientRect(); const [cols, rows] = state.gridData.gridSize; const padding = 40; const cellSize = Math.max(10, Math.floor(Math.min((width - padding) / cols, (height - padding) / rows))); Object.entries(state.gridData.agents).forEach(([id, path]) => { const agentGroup = d3.select(`#agent-group-${id}`); if (agentGroup.empty() || path.length === 0) return; let currentPos = path[0].cell; for(const step of path) { if (step.time <= time) { currentPos = step.cell; } else { break; } } const goalPos = path[path.length - 1].cell; const atGoal = (currentPos[0] === goalPos[0] && currentPos[1] === goalPos[1]); agentGroup.transition().duration(200).attr('transform', `translate(${currentPos[0] * cellSize}, ${currentPos[1] * cellSize})`).style('opacity', atGoal ? 0.5 : 1.0); }); },
                toggleAnimation() { if (state.animationInterval) { clearInterval(state.animationInterval); state.animationInterval = null; this.dom.playPauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>`; } else { this.dom.playPauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>`; state.animationInterval = setInterval(() => { let currentTime = parseInt(this.dom.timeSlider.value); currentTime = (currentTime >= parseInt(this.dom.timeSlider.max)) ? 0 : currentTime + 1; this.updateSimulation(currentTime); }, config.animationSpeed); } }
            };
        
            const app = {
                async executeSparqlQuery(queryString, displayInTab = false) {
                    if (!state.rdfStore) { const msg = "RDF Data not loaded."; if (displayInTab) ui.dom.sparqlResult.innerHTML = `<p>${msg}</p>`; console.error(msg); return []; }
                    try {
                        let fullQuery = '';
                        Object.entries(config.prefixes).forEach(([prefix, uri]) => { fullQuery += `PREFIX ${prefix}: <${uri}>\n`; });
                        fullQuery += '\n' + queryString;
                        const bindingsStream = await engine.queryBindings(fullQuery, { sources: [state.rdfStore] });
                        const bindings = await bindingsStream.toArray();
                        const results = bindings.map(binding => { const result = {}; binding.forEach((value, key) => { result[key.value] = value.value; }); return result; });
                        results.forEach(row => {
                            Object.keys(row).forEach(key => {
                                if (key.toLowerCase().includes('timestamp') || key.toLowerCase().includes('ts')) {
                                    row[key] = parseTimestamp(row[key]);
                                }
                            });
                            if (row.plan && typeof row.plan === 'string' && row.plan.includes('#')) row.plan = `...${row.plan.split('#').pop()}`;
                        });
                        if (displayInTab) { ui.dom.sparqlResult.innerHTML = (results.length > 0) ? ui.createResultsTable(results) : '<p>Query returned no results.</p>'; }
                        return results;
                    } catch (error) {
                        console.error('SPARQL execution error:', error);
                        if (displayInTab) ui.dom.sparqlResult.innerHTML = `<p style="color:var(--color-conflict)">Query execution failed:</p><pre>${error.message}</pre>`;
                        return [];
                    }
                },
        
                async handleTtlUpload(event) {
                    const file = event.target.files[0]; if (!file) return;
                    try {
                        ui.dom.metadataDisplay.innerHTML = '<div class="loading">Loading and parsing TTL file...</div>';
                        ui.dom.metadataDisplay.style.display = 'block';
                        state.ttlContent = await file.text();
                        state.fileName = file.name;
                        if (!state.ttlContent) throw new Error('File is empty or could not be read');
                        state.rdfStore = await rdfProcessor.parseAndStore(state.ttlContent);
                        state.gridData = await rdfProcessor.extractGridData(state.rdfStore);
                        if (!state.gridData || !state.gridData.gridSize || state.gridData.gridSize[0] === 0) {
                            throw new Error('Failed to extract valid grid data from TTL file');
                        }
                        ui.displayMetadata();
                        const maxTime = Math.max(0, ...Object.values(state.gridData.agents).flatMap(p => p.map(s => s.time)));
                        ui.dom.timeSlider.max = maxTime;
                        ui.drawGrid();
                        ui.updateSimulation(0);
                        ui.switchView('grid');
                        this.showInitialExplanationView();
                    } catch (error) {
                        console.error('Error processing TTL file:', error);
                        alert(`Error processing TTL file: ${error.message}`);
                        ui.dom.metadataDisplay.style.display = 'none';
                        ui.dom.uploadSection.style.display = 'block';
                        state.gridData = null; state.rdfStore = null;
                        ui.drawGrid();
                    }
                },
                
                showInitialExplanationView() {
                    ui.highlightConflicts([]);
                    state.lastInteraction = {};
                    if (state.gridData?.agents) {
                        const agentIds = Object.keys(state.gridData.agents);

                        // --- FIX IS HERE: Sort the agent IDs numerically ---
                        agentIds.sort((a, b) => {
                            const numA = parseInt(a.split('-').pop(), 10);
                            const numB = parseInt(b.split('-').pop(), 10);
                            return numA - numB;
                        });

                        ui.dom.agentSelect.innerHTML = agentIds
                            .map(id => `<option value="${id.split(':').pop() || id}">${ui.getAgentDisplayName(id)}</option>`).join('');
                    }
                    const generalQuestions = [
                        { text: "Provide a global plan summary", queryKey: "getPlanMakespan", params: {} },
                        { text: "What is the final cost for each agent?", queryKey: "getCostByAgent", params: {} },
                        { text: "Find most congested locations", queryKey: "findMostCongestedLocations", params: {} }
                    ];
                    ui.renderInitialQuestionList(generalQuestions, "Plan & Agent Analysis", true);
                },
                
                showAgentSpecificView() {
                    const agentId = ui.dom.agentSelect.value;
                    const agentName = ui.getAgentDisplayName(agentId);
                    const agentQuestions = [
                        { text: `What is ${agentName}'s final plan?`, queryKey: 'getAgentFinalPlan', params: { agentId } },
                        { text: `What conflicts was ${agentName} in?`, queryKey: 'getAllAgentConflicts', params: { agentId } },
                        { text: `Compare ${agentName}'s original vs. resolved plan`, queryKey: 'compareOriginalResolved', params: { agentId } },
                        { text: `Show ${agentName}'s full resolution history`, queryKey: 'getAgentResolutionHistory', params: { agentId } }
                    ];
                    ui.renderInitialQuestionList(agentQuestions, `Analysis for ${agentName}`, false);
                    ui.addGoBackButton();
                },
    
                handleCellClick(x, y) {
                    ui.highlightConflicts([]);
                    state.lastInteraction = {};
                    if (!state.gridData) return;
                    const currentTime = parseInt(ui.dom.timeSlider.value);
                    let agentsAtTime = Object.entries(state.gridData.agents).filter(([, path]) => path.some(step => step.time === currentTime && step.cell[0] === x && step.cell[1] === y)).map(([agentId]) => agentId.split('#').pop());
                    const content = { agents: agentsAtTime, isObstacle: state.gridData.obstacles.some(obs => obs[0] === x && obs[1] === y), conflicts: state.gridData.conflicts.filter(c => c.raw_location === `${x},${y}`) };
                    state.lastInteraction = { type: 'cell_click', x, y, content, time: currentTime };
                    let questions = [];
                    const locationStr = `${x},${y}`;
                    if (content.isObstacle) questions.push({text: "This is a static obstacle.", isInfo: true});
                    if (content.agents.length > 0) {
                        content.agents.forEach(agentId => {
                            const agentName = ui.getAgentDisplayName(agentId);
                            questions.push({ text: `What is ${agentName}'s final plan?`, queryKey: 'getAgentFinalPlan', params: { agentId } });
                            questions.push({ text: `Show ${agentName}'s full resolution history`, queryKey: 'getAgentResolutionHistory', params: { agentId } });
                        });
                    }
                    if (content.conflicts.length > 0) {
                        questions.push({ text: `List all conflicts at location (${x},${y})`, queryKey: 'getAllConflictsAtLocation', params: { locationStr } });
                    }
                    if (questions.length === 0 && !content.isObstacle) questions.push({text: "This is an empty cell.", isInfo: true});
                    ui.renderInitialQuestionList(questions, `Explanation for Cell (${x},${y})`, false);
                    ui.addGoBackButton();
                },
        
                async handleQuestionClick(event) {
                    const button = event.target.closest('.question-btn'); if (!button) return;
                    const type = button.dataset.type;
                    if (type === 'back-to-initial') { this.showInitialExplanationView(); return; }
                    const questionText = button.textContent;
                    const queryKey = button.dataset.queryKey;
                    let params = JSON.parse(button.dataset.params || '{}');
                    state.lastInteraction = { ...state.lastInteraction, type: 'question_click', queryKey, params };
                    if (params.conflictURI) state.lastInteraction.conflictURI = params.conflictURI;
                    if (queryKey && sparqlQueries[queryKey]) {
                        const query = sparqlQueries[queryKey](params);
                        const results = await this.executeSparqlQuery(query);
                        await explanationEngine.generateExplanation(questionText, queryKey, results);
                    }
                },
        
                init() {
                    document.querySelectorAll('.view-switcher button').forEach(btn => btn.addEventListener('click', () => ui.switchView(btn.dataset.view)));
                    ui.dom.ttlInput.addEventListener('change', (e) => this.handleTtlUpload(e));
                    ui.dom.runSparqlBtn.addEventListener('click', () => this.executeSparqlQuery(ui.dom.sparqlQuery.value, true));
                    ui.dom.explanationPanelContainer.addEventListener('click', (e) => this.handleQuestionClick(e));
                    ui.dom.selectAgentBtn.addEventListener('click', (e) => { e.stopPropagation(); this.showAgentSpecificView(); });
                    ui.dom.playPauseBtn.addEventListener('click', () => ui.toggleAnimation());
                    ui.dom.timeSlider.addEventListener('input', (e) => ui.updateSimulation(parseInt(e.target.value)));
                    new ResizeObserver(() => ui.drawGrid()).observe(document.getElementById('grid'));
                    ui.drawGrid();
                }
            };
        
            app.init();
        });
    </script>
</body>
</html>